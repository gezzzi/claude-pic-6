<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Stream</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-size: 12px;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0f0;
        }

        .hud-item {
            margin: 5px 0;
            opacity: 0.8;
        }

        .data-flow {
            position: absolute;
            color: #0f0;
            font-size: 10px;
            font-family: monospace;
            pointer-events: none;
            animation: dataFall 5s linear infinite;
        }

        @keyframes dataFall {
            0% {
                transform: translateY(-100vh);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh);
                opacity: 0;
            }
        }

        .matrix-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 0, 0.03) 2px,
                rgba(0, 255, 0, 0.03) 4px
            );
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    <div class="hud">
        <div class="hud-item">SYSTEM: ONLINE</div>
        <div class="hud-item">PACKETS: <span id="packets">0</span></div>
        <div class="hud-item">BANDWIDTH: <span id="bandwidth">0</span> GB/s</div>
        <div class="hud-item">NODES: <span id="nodes">0</span></div>
    </div>
    <div id="dataContainer"></div>

    <script>
        let scene, camera, renderer;
        let dataNodes = [];
        let connections = [];
        let packets = [];
        let time = 0;
        let packetCount = 0;

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Create data nodes
            const nodeCount = 20;
            const nodeGeometry = new THREE.OctahedronGeometry(1, 0);
            
            for (let i = 0; i < nodeCount; i++) {
                const nodeMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                node.position.set(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40
                );
                node.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    )
                };
                
                dataNodes.push(node);
                scene.add(node);
            }

            // Create connections
            updateConnections();

            // Create initial data packets
            for (let i = 0; i < 50; i++) {
                createPacket();
            }

            // Create background data rain
            createDataRain();

            window.addEventListener('resize', onWindowResize);
        }

        function updateConnections() {
            // Remove old connections
            connections.forEach(line => scene.remove(line));
            connections = [];

            // Create new connections
            for (let i = 0; i < dataNodes.length; i++) {
                for (let j = i + 1; j < dataNodes.length; j++) {
                    const distance = dataNodes[i].position.distanceTo(dataNodes[j].position);
                    if (distance < 15) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            dataNodes[i].position,
                            dataNodes[j].position
                        ]);
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0.2
                        });
                        const line = new THREE.Line(geometry, material);
                        connections.push(line);
                        scene.add(line);
                    }
                }
            }
        }

        function createPacket() {
            const packetGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            const packetMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            
            const packet = new THREE.Mesh(packetGeometry, packetMaterial);
            const sourceNode = dataNodes[Math.floor(Math.random() * dataNodes.length)];
            const targetNode = dataNodes[Math.floor(Math.random() * dataNodes.length)];
            
            packet.position.copy(sourceNode.position);
            packet.userData = {
                source: sourceNode,
                target: targetNode,
                progress: 0,
                speed: 0.02 + Math.random() * 0.03
            };
            
            packets.push(packet);
            scene.add(packet);
            packetCount++;
        }

        function createDataRain() {
            const dataContainer = document.getElementById('dataContainer');
            setInterval(() => {
                const dataFlow = document.createElement('div');
                dataFlow.className = 'data-flow';
                dataFlow.style.left = Math.random() * window.innerWidth + 'px';
                dataFlow.style.animationDelay = Math.random() * 5 + 's';
                dataFlow.textContent = Math.random().toString(2).substr(2, 8);
                dataContainer.appendChild(dataFlow);
                
                setTimeout(() => dataFlow.remove(), 5000);
            }, 100);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate nodes
            dataNodes.forEach((node, index) => {
                node.position.add(node.userData.velocity);
                node.rotation.x += 0.01;
                node.rotation.y += 0.01;
                
                // Bounce off boundaries
                if (Math.abs(node.position.x) > 20) node.userData.velocity.x *= -1;
                if (Math.abs(node.position.y) > 20) node.userData.velocity.y *= -1;
                if (Math.abs(node.position.z) > 20) node.userData.velocity.z *= -1;
                
                // Pulse effect
                node.scale.setScalar(1 + Math.sin(time * 5 + index) * 0.2);
            });

            // Update connections
            if (Math.floor(time) % 2 === 0) {
                updateConnections();
            }

            // Animate packets
            packets = packets.filter(packet => {
                packet.userData.progress += packet.userData.speed;
                
                if (packet.userData.progress >= 1) {
                    scene.remove(packet);
                    return false;
                }
                
                packet.position.lerpVectors(
                    packet.userData.source.position,
                    packet.userData.target.position,
                    packet.userData.progress
                );
                
                packet.rotation.x += 0.1;
                packet.rotation.y += 0.1;
                
                return true;
            });

            // Create new packets
            if (Math.random() < 0.1) {
                createPacket();
            }

            // Update HUD
            document.getElementById('packets').textContent = packets.length;
            document.getElementById('bandwidth').textContent = (Math.sin(time) * 50 + 100).toFixed(1);
            document.getElementById('nodes').textContent = dataNodes.length;

            // Camera movement
            camera.position.x = Math.sin(time * 0.2) * 30;
            camera.position.y = Math.cos(time * 0.15) * 20;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>